<!DOCTYPE html>
<html lang="en-us">
<head>
  <title>
    Understanding RPCs - Part II - hack(pravj) | Pravendra Singh
  </title>

  <link href="http://gmpg.org/xfn/11" rel="profile">
<meta http-equiv="content-type" content="text/html; charset=utf-8">

<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="description" content="My name is Pravendra Singh and I love playing with data. R(ETL)PL."/>
<meta name="keywords" content="blog, web, data, data visualization, golang, programming, python, Pravendra Singh, Pravendra, pravj, IIT, IIT Roorkee">
<meta name="author" content="Pravendra Singh">
<meta http-equiv="cleartype" content="on">

  <meta property="og:locale" content="en_US">
<meta property="og:site_name" content="Pravendra Singh - Falling Leaves">
<meta property="og:title" content="Understanding RPCs - Part II" />
<meta property="og:type" content="article" />
<meta property="og:locale" content="en_US" />
<meta property="og:url" content="https://pravj.github.io/articles/understanding-rpcs-partii/" />
<meta property="og:description" content="In the previous post, we introduced remote procedure calls and their use within a distributed system. In this post, we are going to dive deep into the concept of semantics - first in the context of distributed systems in general and then discuss various RPC semantics.
Semantics We&rsquo;re now going to briefly talk about one of the most important aspects in a distributed systems - semantics. What do you mean by semantics?" />

<meta property="og:image" content="http://prakhar.me/images/rpcs.jpg"/>

<meta property="article:author" content="https://www.facebook.com/hackpravj" />
<meta property="article:publisher" content="https://www.facebook.com/hackpravj" />

  <meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@hackpravj">
<meta name="twitter:creator" content="@hackpravj">
<meta name="twitter:title" content="Understanding RPCs - Part II" />
<meta name="twitter:description" content="In the previous post, we introduced remote procedure calls and their use within a distributed system. In this post, we are going to dive deep into the concept of semantics - first in the context of distributed systems in general and then discuss various RPC semantics.
Semantics We&rsquo;re now going to briefly talk about one of the most important aspects in a distributed systems - semantics. What do you mean by semantics?" />


<meta property="twitter:image" content="http://prakhar.me/images/rpcs.jpg"/>





  <link href='https://fonts.googleapis.com/css?family=Raleway:400|Source+Serif+Pro:400,300,600' rel='stylesheet' type='text/css'>

  
  <link rel="stylesheet" href="https://pravj.github.io/styles.min.css">

  

  

  
  <link rel="apple-touch-icon" sizes="180x180" href="/images/header-images/apple-touch-icon.png">
  <link rel="icon" type="image/png" href="/images/header-images/favicon-32x32.png" sizes="32x32">
  <link rel="icon" type="image/png" href="/images/header-images/favicon-16x16.png" sizes="16x16">
  <link rel="mask-icon" href="/images/header-images/safari-pinned-tab.svg" color="#5bbad5">
  <link rel="manifest" href="/manifest.json">
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/images/header-images/touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/images/header-images/favicon.ico">

  
  <link href="" rel="alternate" type="application/rss+xml" title="hack(pravj)" />


  
</head>


<body>
      <div class="post-header">
  <div class="container rrr">
    <div class="row">
      <div class="six columns">
        <h4><a href="/">PRAVENDRA SINGH</a></h4>
      </div>
      <div class="six columns">
        <nav>
          <ul class="nav-list">
            <li><a href="/about" title="About Me"><i class="icon-user"></i></a></li>
            <li><a href="/blog" title="Articles"><i class="icon-article-alt"></i></a></li>
            <li><a href="/projects" title="Projects"><i class="icon-github-circled"></i></a></li>
            <li><a href="/quotes" title="Quotes"><i class="icon-quote-left"></i></a></li>
          </ul>
        </nav>
      </div>
    </div>
  </div>
</div>




  <div class="container">
    <div class="row">

      <section>
            <h1 class="post-title">
              <a href="/articles/understanding-rpcs-partii/">Understanding RPCs - Part II</a>
            </h1>

          <div class="post-content-meta">

            
              <i class="icon-calendar"></i>  
              <span class="post-date">
                <span class="post-date-month">September</span> 
                <span class="post-date-day"> 24, </span>
                <span class="post-date-year">2015</span>
              </span> 
            

            
            
                <span class="post-tag"> in </span>
                
                <a class="post-tag post-tag-distributed-systems" href="https://pravj.github.io/tags/distributed-systems">
                  <i class="icon-tag"></i>distributed-systems</a>
                
                <a class="post-tag post-tag-papers" href="https://pravj.github.io/tags/papers">
                  <i class="icon-tag"></i>papers</a>
                
            

         </div>

			

      <div class="post-content">
        

<p>In the <a href="/google.com">previous</a> post, we introduced remote procedure calls and their use within a distributed system. In this post, we are going to dive deep into the concept of semantics - first in the context of distributed systems in general and then discuss various RPC semantics.</p>

<h3 id="semantics">Semantics</h3>

<p>We&rsquo;re now going to briefly talk about one of the most important aspects in a distributed systems - semantics. What do you mean by semantics? Before we get to that, let&rsquo;s talk about failures.  As we all know, failures are the norm rather than an exception in a distributed system. Failures be of many forms - network, machine or even datacenters. Hence, one of the goals in designing a distributed system is for it to be fault tolerant. We would ideally want our systems to hide the failures as much as possible and be available to our users.</p>

<p>However, as we&rsquo;ll learn later, all kinds of failures cannot be completely hidden from the user. When one of the replica goes down, you can hide that from the user but when the majority go down it can be very hard to keep the system functioning. So what happens when your system cannot handle a failure mode or has some other limitation? The idea is to expose those <strong>semantics</strong> very clearly in your APIs to your users so that they can then in turn plan for that scenario.</p>

<p>One such example can be found in <a href="http://rethinkdb.com/docs/consistency/#settings">RethinkDB docs</a> under the write acknowledgements section which is a configuration setting that can be set by the user.</p>

<blockquote>
<p>The default is majority, meaning writes will be acknowledged when a majority of (voting) replicas have confirmed their writes. The other possible option is single, meaning writes will be acknowledged when a single replica acknowledges it.</p>
</blockquote>

<p>By giving this option to the user, the creators of the RethinkDB allow the users to make a tradeoff between safety and performance.</p>

<blockquote>
<p>RethinkDBâ€™s default settings prioritize safety over performance, except in one case: read_mode defaults to single rather than majority. The majority read mode requires sending a query to all of the replicas and waiting for a majority to reply, which significantly degrades performance.</p>
</blockquote>

<p>Hence, by clearly laying out semantics designers of distributed systems can keep their users informed.</p>

<h3 id="rpcs-semantics">RPCs Semantics</h3>

<p>With that out of the way, let&rsquo;s see how what kind of semantics are exposed by RPCs. One very important point to consider is that since RPCs are the building blocks of distributed systems, the semantics dictated by RPCs bubble up to higher layers and affect the design of a distributed system.</p>

<p>In the previous post we took at look at one of the key design goals of an RPC system.</p>

<blockquote>
<p>Make the process of executing code on a remote machine as simple and straight-forward as calling a local function.</p>
</blockquote>

<p>Surely this is a very worthwhile goal to pursue. Having a model that works similar to the local environment helps programmers in reasoning easily about the program and makes it easier to build distributed systems application. But the question remains that how far do RPCs systems generally come in achieveing this goal. How similar are they to LPCs (Local Procedure Calls) and to what extent does it the free the programmer from the mental overhead of thinking about communication in a distributed system?</p>

<p>Let&rsquo;s say you are writing a program and decide to make a local procedure call. In this case two things can happen -</p>

<ol>
<li>The call returns which means that either procedure was successful or it met with an exception.</li>
<li>The call didn&rsquo;t return which means that it got stuck in an infinite loop and it didn&rsquo;t complete. In this case, the call was not successful.</li>
</ol>

<p>In both these cases, the final state of the system is clearly known and is easy to reason about. In our day-to-day work we deal with each scenarios multiple times and by now have become well equipped to deal with them.</p>

<p>When communicating over a network, things are not this straightforward. Consider the case when the programmer makes a remote procedure call. When the call returns, you know that the call succeeded - it&rsquo;s all fine and dandy. However, when the call fails then are multiple scenarios that could&rsquo;ve happened -</p>

<ol>
<li>The call didn&rsquo;t reach the server.</li>
<li>The call was executed but mid-way the server crashed.</li>
<li>The call was executed, the results were returned but the return message did not reach the client.</li>
</ol>

<p>All of a sudden, something which seemed quite trivial has become sufficiently complex. To some extent, some of these problems can be dealt with repeated <code>ACK</code>s between the server and client. This is the approach as taken by the paper. The challenge with these approaches is that more messages put a stronger bound on the performance of the system.</p>

<p>In the face of these difficulties, there are three <strong>semantics</strong> that have been proposed for RPC systems -</p>

<h4 id="at-least-once">At-least-once</h4>

<p>At-least-once are the easiest to implement. As you can guess, the promise here is that the call would be executed one times or more. The way this works that the client keeps making the call to the server as long as it doesn&rsquo;t recieve an <code>ACK</code>. In case the call is executed on the remote service but the <code>ACK</code> got lost, the client re-sends the call and server executes it. Quite clearly, one can see that the call might be executed multiple times - this is precisely where the at-least-once semantics comes from. The psuedo-code for this can look like the following -</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span></span><span class="n">method_executed</span> <span class="o">=</span> <span class="bp">False</span>
<span class="k">while</span> <span class="ow">not</span> <span class="n">method_executed</span><span class="p">:</span>
    <span class="n">ack</span> <span class="o">=</span> <span class="n">send_RPC_and_wait_for_ack</span><span class="p">(</span><span class="n">timeout</span><span class="o">=</span><span class="n">T</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ack</span> <span class="ow">and</span> <span class="n">ack</span><span class="o">.</span><span class="n">SUCCESS</span><span class="p">:</span>
        <span class="n">method_executed</span> <span class="o">=</span> <span class="bp">True</span>
</code></pre></div>


<p>When would this be useful? These semantics are useful when the operation being requested by the client is <strong>idempodent</strong> i.e repeated executions of the same call do not affect the state. An example of an idempodent operation is the setting a bit to 1 when it is zero and not doing anything otherwise. No matter how many times you call this operation, once the bit has been set, subsequent calls do not change the state.</p>

<h4 id="at-most-once">At-most-once</h4>

<p>In at-most-once the server either executes the call once or not at all. The client makes a call, the server executes it and sends an <code>ACK</code>. Whether or not the <code>ACK</code> is received by the client, the server does not run the procedure again.</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span></span><span class="n">request_sent</span> <span class="o">=</span> <span class="bp">False</span>
<span class="k">while</span> <span class="ow">not</span> <span class="n">request_sent</span><span class="p">:</span> <span class="c1"># only care about msg delivery</span>
    <span class="n">ack</span> <span class="o">=</span> <span class="n">send_RPC_and_wait_for_ack</span><span class="p">(</span><span class="n">timeout</span><span class="o">=</span><span class="n">T</span><span class="p">)</span>
    <span class="n">request_sent</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="k">if</span> <span class="n">ack</span> <span class="ow">and</span> <span class="n">ack</span><span class="o">.</span><span class="n">FAILURE</span><span class="p">:</span>
        <span class="n">request_sent</span> <span class="o">=</span> <span class="bp">True</span>
</code></pre></div>


<h4 id="exactly-once">Exactly-once</h4>

<p>Exactly-once semantics are the gold standard of RPC semantics. It guarantees that each call is executed just once thereby mimicing a local procedure call. However, exactly-once semantics are extremely hard to build given the complexities in a distributed system.</p>

<p>To understand where the difficulty comes from let&rsquo;s think about storing some state on the server to keep track of what all calls have been completed. This way when a new call comes in, depending on whether it has been executed or not we can take an appropriate action.</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span></span><span class="c1"># On the server side</span>
<span class="n">state</span> <span class="o">=</span> <span class="p">{}</span>                       <span class="c1"># to manage the state</span>
<span class="k">if</span> <span class="ow">not</span> <span class="n">state</span><span class="p">[</span><span class="n">client</span><span class="p">][</span><span class="n">method</span><span class="p">]:</span>    <span class="c1"># if not executed previously</span>
    <span class="n">resp</span> <span class="o">=</span> <span class="n">handle</span><span class="p">(</span><span class="n">method</span><span class="p">)</span>        <span class="c1"># (1)</span>
    <span class="n">state</span><span class="p">[</span><span class="n">client</span><span class="p">][</span><span class="n">method</span><span class="p">]</span> <span class="o">=</span> <span class="n">resp</span> <span class="c1"># (2) </span>
    <span class="k">return</span> <span class="n">resp</span>
<span class="k">else</span><span class="p">:</span>                            <span class="c1"># has been executed previously</span>
    <span class="k">return</span> <span class="n">state</span><span class="p">[</span><span class="n">client</span><span class="p">][</span><span class="n">method</span><span class="p">]</span> <span class="c1"># return cached response</span>
</code></pre></div>


<p>Though the code above simple there are two big assumptions that it rests on. For starters, consider what happens when the server fails after executing <code>(1)</code> but before <code>(2)</code>. In this case, the server hasn&rsquo;t actually recorded the fact that the execution is complete. When the server is brought back up, and the client sends the request again, the server ends up executing the call again. Hence, the exactly-once semantics are broken.</p>

<p>One way out then is to find a way to make <code>(1)</code> and <code>(2)</code> atomic - ensuring either both of these commands execute or none of these commands execute. If you&rsquo;ve done a course on databases, you know that this itself is a hard problem to solve.</p>

<h3 id="other-limitations">Other limitations</h3>

<p>Aside from the semantics, there are two other aspects of RPCs which are worth talking about -</p>

<ol>
<li><p><strong>Address Space</strong>: Suppose you&rsquo;re making a local call and you need to pass in a big datastruture (e.g. linked list with 1000 nodes) to the method. How do you do that? You pass a reference to the object. The reason why this works is that in local call, the caller and the callee share the same address space. This is not true in an RPC. In such a scenario, you have to think about creative ways of wiring over a big datastructure efficiently over the network.</p></li>

<li><p><strong>Performance</strong>: Performance in a RPC system is order of magnitude slower than the equivalent local call. Apart from the overhead of marshalling etc. the very fact is that the Round-trip-time puts a lower bound on performance - which in itself is substantial. Hence, typically RPC systems addtionally have an asynchronous version of their API so that the main thread on the caller is not blocked while it waits for the results.</p></li>
</ol>

<h3 id="conclusion">Conclusion</h3>

<p>In conclusion what we&rsquo;ve seen is the mere fact of adding an unreliable network makes the goals of building a LPC-like abstraction so elusive. Although most of these problems have been solved to a large extent thanks to latest advances &amp; the research but the point remains that the RPCs are much more complex than they seem to be. Hopefully with these set of blog posts, I&rsquo;ve whetted your appetite enough to pursue these topics further.</p>

<p>Till next time!</p>

      </div>
	
			

      </div>

      <div class="row paging">
			
          
          <div class="six columns">
            <a class="paging-link" href="/articles/understanding-rpcs/"><i class="icon-left-open"></i> Understanding RPCs - Part I</a>
          </div>
          

					
          <div class="paging-newer six columns">
            <a class="paging-link" href="/blog/indian-ecommerce/">Breaking into the Indian E-commerce <i class="icon-right-open"></i></a>
          </div>
          

      
       </div>


    </div>
  </div>

  
  <div class="container">
    <div class="row" id="disqus_area">
      <a href="#" id="disqus_load" onclick="return loadDisqus()">Add / View Comments</a>
<div id="disqus_thread"></div>

<script type="text/javascript">
  var disqus_shortname = 'pravj';

  function loadDisqus() {
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();

  
  document.getElementById('disqus_load').style.display = 'none';
  return false;
}
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

    </div>
  </div>
  


	

	

    <script type="text/javascript">
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-48537986-1', 'auto');
  ga('send', 'pageview');
</script>

    </div>
      <div class="footer">
	<hr class="thin" />
  <p>Powered by <a href="https://gohugo.io/">Hugo</a> on <a href="https://pages.github.com/">GitHub Pages</a></p>
</div>

  </div>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="https://pravj.github.io/main.js"></script>






<script async defer src="https://buttons.github.io/buttons.js"></script>



</body>
</html>
