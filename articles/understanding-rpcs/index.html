<!DOCTYPE html>
<html lang="en-us">
<head>
  <title>
    Understanding RPCs - Part I - hack(pravj) | Pravendra Singh
  </title>

  <link href="http://gmpg.org/xfn/11" rel="profile">
<meta http-equiv="content-type" content="text/html; charset=utf-8">

<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="description" content="My name is Pravendra Singh and I love playing with data. R(ETL)PL."/>
<meta name="keywords" content="blog, web, data, data visualization, golang, programming, python, Pravendra Singh, Pravendra, pravj, IIT, IIT Roorkee">
<meta name="author" content="Pravendra Singh">
<meta http-equiv="cleartype" content="on">

  <meta property="og:locale" content="en_US">
<meta property="og:site_name" content="Pravendra Singh - Falling Leaves">
<meta property="og:title" content="Understanding RPCs - Part I" />
<meta property="og:type" content="article" />
<meta property="og:locale" content="en_US" />
<meta property="og:url" content="https://pravj.github.io/articles/understanding-rpcs/" />
<meta property="og:description" content="Having looked at a distributed system i.e the domain name system in the previous post, lets turn our attention to something more fundamental. In this blog post, we are going to start diving deeper into one of the basic blocks of Distributed Systems - Remote Procedure Calls or RPCs.
The paper that we&rsquo;re going to be looking at today is authored by the duo of Nelson and Birell who were the first set of people to build an RPC implementation for their work at Xerox PARC." />

<meta property="og:image" content="http://prakhar.me/images/rpcs.jpg"/>

<meta property="article:author" content="https://www.facebook.com/hackpravj" />
<meta property="article:publisher" content="https://www.facebook.com/hackpravj" />

  <meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@hackpravj">
<meta name="twitter:creator" content="@hackpravj">
<meta name="twitter:title" content="Understanding RPCs - Part I" />
<meta name="twitter:description" content="Having looked at a distributed system i.e the domain name system in the previous post, lets turn our attention to something more fundamental. In this blog post, we are going to start diving deeper into one of the basic blocks of Distributed Systems - Remote Procedure Calls or RPCs.
The paper that we&rsquo;re going to be looking at today is authored by the duo of Nelson and Birell who were the first set of people to build an RPC implementation for their work at Xerox PARC." />


<meta property="twitter:image" content="http://prakhar.me/images/rpcs.jpg"/>





  <link href='https://fonts.googleapis.com/css?family=Raleway:400|Source+Serif+Pro:400,300,600' rel='stylesheet' type='text/css'>

  
  <link rel="stylesheet" href="https://pravj.github.io/styles.min.css">

  

  

  
  <link rel="apple-touch-icon" sizes="180x180" href="/images/header-images/apple-touch-icon.png">
  <link rel="icon" type="image/png" href="/images/header-images/favicon-32x32.png" sizes="32x32">
  <link rel="icon" type="image/png" href="/images/header-images/favicon-16x16.png" sizes="16x16">
  <link rel="mask-icon" href="/images/header-images/safari-pinned-tab.svg" color="#5bbad5">
  <link rel="manifest" href="/manifest.json">
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/images/header-images/touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/images/header-images/favicon.ico">

  
  <link href="" rel="alternate" type="application/rss+xml" title="hack(pravj)" />


  
</head>


<body>
      <div class="post-header">
  <div class="container rrr">
    <div class="row">
      <div class="six columns">
        <h4><a href="/">PRAVENDRA SINGH</a></h4>
      </div>
      <div class="six columns">
        <nav>
          <ul class="nav-list">
            <li><a href="/about" title="About Me"><i class="icon-user"></i></a></li>
            <li><a href="/blog" title="Articles"><i class="icon-article-alt"></i></a></li>
            <li><a href="/projects" title="Projects"><i class="icon-github-circled"></i></a></li>
            <li><a href="/quotes" title="Quotes"><i class="icon-quote-left"></i></a></li>
          </ul>
        </nav>
      </div>
    </div>
  </div>
</div>




  <div class="container">
    <div class="row">

      <section>
            <h1 class="post-title">
              <a href="/articles/understanding-rpcs/">Understanding RPCs - Part I</a>
            </h1>

          <div class="post-content-meta">

            
              <i class="icon-calendar"></i>  
              <span class="post-date">
                <span class="post-date-month">September</span> 
                <span class="post-date-day"> 23, </span>
                <span class="post-date-year">2015</span>
              </span> 
            

            
            
                <span class="post-tag"> in </span>
                
                <a class="post-tag post-tag-distributed-systems" href="https://pravj.github.io/tags/distributed-systems">
                  <i class="icon-tag"></i>distributed-systems</a>
                
                <a class="post-tag post-tag-papers" href="https://pravj.github.io/tags/papers">
                  <i class="icon-tag"></i>papers</a>
                
            

         </div>

			

      <div class="post-content">
        

<p>Having looked at a distributed system i.e the domain name system in the <a href="/articles/the-domain-name-system/">previous</a> post, lets turn our attention to something more fundamental. In this blog post, we are going to start diving deeper into one of the basic blocks of Distributed Systems - Remote Procedure Calls or RPCs.</p>

<p>The <a href="http://www.cs.virginia.edu/~zaher/classes/CS656/birrel.pdf">paper</a> that we&rsquo;re going to be looking at today is authored by the duo of <a href="https://en.wikipedia.org/wiki/Bruce_Jay_Nelson">Nelson</a> and <a href="https://birrell.org/andrew/me/bio.php">Birell</a> who were the first set of people to build an RPC implementation for their work at Xerox PARC. Nelson incidentally is also credited for the coining the term!</p>

<h3 id="why-rpcs">Why RPCs?</h3>

<p>In the last post, we defined a distributed system as below -</p>

<blockquote>
<p>A distributed system is a set of <em>independent</em> machines that <em>coordinate</em> over a <em>network</em> to achieve a common goal.</p>
</blockquote>

<p>One of the important keywords in the above definition is <em>coordinate</em>. However, in order to coordinate, systems first need a way to communicate. Given that we have a messaging layer (the network) what kind of a communication abstraction we can build that can be helpful to programmers while building distributed systems?</p>

<p>RPCs are one such abstraction borrowed from programming languages that have a simple goal:</p>

<blockquote>
<p>Make the process of executing code on a remote machine as simple and straight-forward as calling a local function.</p>
</blockquote>

<p>But why did we specifically choose procedures? Let&rsquo;s hear what the authors have to say -  <em>RPCs are based on the observation that procedure calls are a well known and well understood mechanism for transfer of control and data within a program running on a single computer. Therefore, it is proposed that this same mechanism be extended to provide for transfer of control and data across a communication network.</em></p>

<h3 id="components">Components</h3>

<figure>
    <img data-action="zoom" src="/images/rpcs.jpg"></img>
    <figcaption>Components involved in a RPC. Image courtesy: Birell and Nelson's RPC paper</figcaption>
</figure>

<p>The underlying mechanism of a RPC is simple - the caller machine makes a procedure call over a network to the callee machine which then executes the procedure locally, collects the results and sends it over to the caller.  The figure above lays out the key components in an RPC system, which at a high-level has two main pieces: a stub generator and the run-time library.</p>

<p>The stubs are responsible for placing a specification and packing / unpacking the arguments falling that specification into the message. This message is then forwarded to the runtime so that it can be wired to the callee (in case of the user-stub). The process of packing the arguments is usually called <strong>marshalling</strong> or <strong>serialization</strong> of the message. Likewise, <strong>unmarshalling</strong> or <strong>deserialization</strong> involves extracting information received into something which the system can understand.</p>

<p>When writing a distributed application, a programmer first writes an interface module in which she specifies the procedure names, the types of the arguments it takes and finally the return types. The compiler then uses this definition and generates the user-stub and the client-stub.</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span></span><span class="c1">// An example of an interface for generating stubs</span>
<span class="n">service</span> <span class="n">FacebookService</span> <span class="o">{</span>
  <span class="c1">// Returns a descriptive name of the service</span>
  <span class="n">string</span> <span class="nf">getName</span><span class="o">(),</span>

  <span class="c1">// Returns the version of the service</span>
  <span class="n">string</span> <span class="nf">getVersion</span><span class="o">(),</span>
    
  <span class="c1">// Gets an option</span>
  <span class="n">string</span> <span class="nf">getOption</span><span class="o">(</span><span class="mi">1</span><span class="o">:</span> <span class="n">string</span> <span class="n">key</span><span class="o">),</span>

  <span class="c1">// Gets all options</span>
  <span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="o">,</span> <span class="n">string</span><span class="o">&gt;</span> <span class="nf">getOptions</span><span class="o">()</span>
<span class="o">}</span>
</code></pre></div>


<p>The runtime is responsible for retransmissions, acknowledgments, packet routing, and encryption. It handles much of the heavy lifting in the RPC system. One of the key challenges faced by the runtime is locating the remote service. Once the service is located, the RPC package then <strong>binds</strong> the importer of the interface to an exporter of the interface.</p>

<h3 id="naming">Naming</h3>

<p>The problem of <strong>naming</strong> is a common one in distributed systems. In a cluster how do we know the names and addresses of each of the machines? How do we maintain this list and do we keep this dynamic? We&rsquo;ll look at these problems much later when we talk about directory services and service discovery.</p>

<p>In the paper the authors use Grapevine, a distributed service that provides DNS service, resource locating service, authentication and mail service.</p>

<p><em>The major attraction of using Grapevine is that it is widely and reliably available. Grapevine is distributed across multiple servers strategically located in our internet topology, and is configured to maintain at least three copies of each database entry. Since the Grapevine servers themselves are highly reliable and the data is replicated, it is extremely rare for us to be unable to look up a database entry.</em></p>

<p>For more info, checkout the <a href="http://web.cs.wpi.edu/~cs4513/d07/Papers/Birrell,%20Levin,%20et.%20al.,%20Grapevine.pdf">paper</a> on Grapevine.</p>

<h3 id="protocol">Protocol</h3>

<p>Once the caller knows which callee it needs to communicate with, the next question is which transport level protocol to use? The authors had an option of going ahead with a PUP byte stream protocol but decided against it as the protocol was ideal for sending bigger data packets. In the case of RPC, the design goal was different -</p>

<blockquote>
<p>One aim we emphasized in our protocol design was minimizing the elapsed real-time between initiating a call and getting results. With protocols for bulk data transfer this is not important: most of the time is spent actually transferring the data.</p>
</blockquote>

<p>In the modern world, we have an option of using UDP (an unreliable protocol) or TCP (a reliable protocol). While the choice might seem clear, the caveat here is that building RPC on top of a reliable communication protocol can lead to a severe drop in performance. Hence, many RPC packages are built on top of unreliable communication layers (e.g. UDP) and then bake in the extra logic for dealing with ACKs, retries etc.</p>

<p>Now would be a good time to talk about <a href="https://thrift.apache.org/">Thrift</a> - the RPC framework developed at Facebook. Thrift has its own interface language called <a href="https://thrift.apache.org/docs/idl">IDL</a> that is used to generate the stubs. The communication protocol uses <a href="https://developers.google.com/protocol-buffers/">protocol buffers</a> as its data format under the hood. Unlike XML/JSON protocol buffers are a binary format and hence is much smaller, less ambiguous and faster than a plain-text data format.</p>

<p><em>Apache Thrift allows you to define data types and service interfaces in a simple definition file. Taking that file as input, the compiler generates code to be used to easily build RPC clients and servers that communicate seamlessly across programming languages.</em></p>

<p>Nowadays Thrift is being used more and more amongst heterogenous services to talk amongst each other - for example, you could write a user authentication service in Java, but call it from your Ruby web application.</p>

<h3 id="conclusion">Conclusion</h3>

<p>In this post we went over the overall idea behind RPCs and took a deep dive into the components which form a RPC system. In the next post we are going to continue our discussion about RPCs by talking about semantics and some limitations of RPCs.</p>

      </div>
	
			

      </div>

      <div class="row paging">
			
          
          <div class="six columns">
            <a class="paging-link" href="/articles/the-domain-name-system/"><i class="icon-left-open"></i> The Domain Name System</a>
          </div>
          

					
          <div class="paging-newer six columns">
            <a class="paging-link" href="/articles/understanding-rpcs-partii/">Understanding RPCs - Part II <i class="icon-right-open"></i></a>
          </div>
          

      
       </div>


    </div>
  </div>

  
  <div class="container">
    <div class="row" id="disqus_area">
      <a href="#" id="disqus_load" onclick="return loadDisqus()">Add / View Comments</a>
<div id="disqus_thread"></div>

<script type="text/javascript">
  var disqus_shortname = 'pravj';

  function loadDisqus() {
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();

  
  document.getElementById('disqus_load').style.display = 'none';
  return false;
}
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

    </div>
  </div>
  


	

	

    <script type="text/javascript">
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-48537986-1', 'auto');
  ga('send', 'pageview');
</script>

    </div>
      <div class="footer">
	<hr class="thin" />
  <p>Powered by <a href="https://gohugo.io/">Hugo</a> on <a href="https://pages.github.com/">GitHub Pages</a></p>
</div>

  </div>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="https://pravj.github.io/main.js"></script>






<script async defer src="https://buttons.github.io/buttons.js"></script>



</body>
</html>
